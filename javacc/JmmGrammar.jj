PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< IMPORT : "import" > |
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< EQUAL : "="> |
	< AND : "&&"> |
	< LESS_THAN : "<"> |
	< MORE_THAN : ">"> |
	< OPEN_BRACKETS : "["> |
	< CLOSE_BRACKETS : "]"> |
	< OPEN_CURLY_BRACKETS: "{">|
	< CLOSE_CURLY_BRACKETS: "}">|
	< TRUE : "true"> |
	< FALSE : "false"> |
	< THIS : "this" > |
	< INT : "int" >|
	< BOOLEAN : "boolean" > |
	< STRING : "string" > |
	< NEW : "new" > |

	< NOT : "!" > |
	< COMMA : "," > |
	< SEMI_COLON : ";" > |
	< PERIOD : "."> |

	< LENGTH : "length" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< THEN : "then" > |
	< WHILE : "while" > |


	< PUBLIC : "public"> |
	< PRIVATE : "private" > |
	< RETURN : "return" > |

	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > | 
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	
	
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER_LITERAL : (["0" - "9"])+ >

;


Start : ImportDeclaration ClassDeclaration <EOF>;

ImportDeclaration : 
	(
		<IMPORT> Identifier
		(
			<PERIOD> Identifier
		)*
		<SEMI_COLON>
	)*
;

ClassDeclaration : 
	<CLASS> Identifier
	(
		<EXTENDS> Identifier
	)? 
	<OPEN_CURLY_BRACKETS>
	(
		VarDeclaration
	)*
	(
		MethodDeclaration
	)*
	<CLOSE_CURLY_BRACKETS>
;

VarDeclaration : Type Identifier <SEMI_COLON>;
	
MethodDeclaration : 
	<PUBLIC> Type Identifier <OPEN_PAREN> 
	(
		Type
		Identifier
		(
			<COMMA>
			Type
			Identifier
		)*
	)?
	<CLOSE_PAREN> <OPEN_CURLY_BRACKETS>
	(
		VarDeclaration
	)*
	(
		Statement
	)*
	<RETURN> Expression <SEMI_COLON> <CLOSE_CURLY_BRACKETS> |
	<PUBLIC> <STATIC> <VOID> <MAIN> <OPEN_PAREN> <STRING> <OPEN_BRACKETS> <CLOSE_BRACKETS> Identifier <CLOSE_PAREN> <OPEN_CURLY_BRACKETS>
	(
		VarDeclaration
	)?
	(
		Statement
	)?
	<CLOSE_CURLY_BRACKETS>
;

Type : 
	< INT > < OPEN_BRACKETS > < CLOSE_BRACKETS > |
	< BOOLEAN > |
	< INT > |
	Identifier
;

Statement:
	<OPEN_CURLY_BRACKETS> (Statement)* <CLOSE_CURLY_BRACKETS> |
	<IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement | 
	<WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement | 
	Expression <SEMI_COLON> | 
	Identifier <EQUALS> Expression <SEMI_COLON>
	Identifier < OPEN_BRACKETS > Expression < CLOSE_BRACKETS > < EQUAL > Expression < SEMI_COLON >
;

Expression: 
	Expression_Recursion ( ( <AND> | <LESS_THAN> | <PLUS> | <MINUS> | <TIMES> | <DIVIDE>) Expression |
	<OPEN_BRACKETS> Expression <CLOSE_BRACKETS> |
	<PERIOD> <LENGTH> | 
	<PERIOD> Identifier <OPEN_PAREN> 
		(Expression 
			(
				<COMMA> 
				Expression
			)*
		)?
		<CLOSE_PAREN> )
	
;

Expression_Recursion : 
	IntegerLiteral | 
	<TRUE> |
	<FALSE> |
	Identifier |
	< THIS > |	 
	< NEW > < INT > < OPEN_BRACKETS > Expression < CLOSE_BRACKETS > |		
	< NEW > Identifier < OPEN_PAREN > < CLOSE_PAREN > |
	< NOT > Expression |
	< OPEN_PAREN > Expression < CLOSE_PAREN >
;



AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	IntegerLiteral
	(
		(< TIMES > | < DIVIDE >)
		IntegerLiteral
	)?
;


