PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES = false;

SKIP : <BLOCK_COMMENT: "/*" (~["/"])* "*/" > | <LINE_COMMENT : "//" (~["\n","\r"])*>  |  " " | "\t" | "\r" | "\n";

TOKEN :
	< IMPORT : "import" > |
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< EQUAL : "="> |
	< AND : "&&"> |
	< LESS_THAN : "<"> |
	< MORE_THAN : ">"> |
	< OPEN_BRACKETS : "["> |
	< CLOSE_BRACKETS : "]"> |
	< OPEN_CURLY_BRACKETS: "{">|
	< CLOSE_CURLY_BRACKETS: "}">|
	< TRUE : "true"> |
	< FALSE : "false"> |
	< THIS : "this" > |
	< INT : "int" >|
	< BOOLEAN : "boolean" > |
	< STRING : "String" > |
	< NEW : "new" > |
	< NOT : "!" > |
	< COMMA : "," > |
	< SEMI_COLON : ";" > |
	< PERIOD : "."> |
	< UNDERSCORE : "_" > |

	< LENGTH : "length" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< THEN : "then" > |
	< WHILE : "while" > |


	< PUBLIC : "public"> |
	< PRIVATE : "private" > |
	< RETURN : "return" > |

	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > | 
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	< AT : "@" > |
    <IDENTIFIER: (["a"-"z"] | ["A"-"Z"] | "_")+ (["0" - "9"] | ["a"-"z"] | ["A"-"Z"] | "_")* >
;

Start : ImportDeclaration ClassDeclaration < EOF >;


Type : 
	< INT > (< OPEN_BRACKETS > < CLOSE_BRACKETS >)? |
	< BOOLEAN > |
	<VOID> |
    <IDENTIFIER>
;   

Statement:
	<OPEN_CURLY_BRACKETS> (Statement)* <CLOSE_CURLY_BRACKETS> |
	<IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement | 
	<WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement |
    LOOKAHEAD <IDENTIFIER> < OPEN_BRACKETS > Expression < CLOSE_BRACKETS > < EQUAL > Expression < SEMI_COLON > |
	LOOKAHEAD <IDENTIFIER> <EQUAL> Expression <SEMI_COLON> |
    Expression <SEMI_COLON> 
;

ImportDeclaration : 
	(<IMPORT> <IDENTIFIER> (<PERIOD> <IDENTIFIER>)* <SEMI_COLON>)* 
;

ClassDeclaration : 
	(<PUBLIC>)?<CLASS> <IDENTIFIER> ( <EXTENDS> <IDENTIFIER> )?  <OPEN_CURLY_BRACKETS>
	(VarDeclaration)*
	(MethodDeclaration)*
	<CLOSE_CURLY_BRACKETS>
;

VarDeclaration : Type <IDENTIFIER> <SEMI_COLON>;
	
NormalMethod : 
	Type <IDENTIFIER> <OPEN_PAREN> ( Type <IDENTIFIER> ( <COMMA> Type <IDENTIFIER>)*)?<CLOSE_PAREN> 
	<OPEN_CURLY_BRACKETS>
	(LOOKAHEAD VarDeclaration | Statement)*
	(<RETURN> Expression <SEMI_COLON>)?
	<CLOSE_CURLY_BRACKETS> 
;

MainMethod :
	<STATIC> <VOID> <MAIN> <OPEN_PAREN> <STRING> <OPEN_BRACKETS> <CLOSE_BRACKETS> (<IDENTIFIER> {jjtThis.put("foo", "bar"); }) #Id <CLOSE_PAREN> <OPEN_CURLY_BRACKETS>
	(LOOKAHEAD VarDeclaration | Statement)*
    
	<CLOSE_CURLY_BRACKETS>
;

MethodDeclaration : 
	<PUBLIC> (MainMethod | NormalMethod)
;

Expression:
	<INTEGER_LITERAL> (Expression2)?| 
	<TRUE> (Expression2)?|
	<FALSE> (Expression2)?|
    <THIS > (Expression2)?|
    <IDENTIFIER> (Expression2)?|	 
	LOOKAHEAD < NEW > < INT > < OPEN_BRACKETS > Expression < CLOSE_BRACKETS > (Expression2)? |		
	< NEW > <IDENTIFIER> < OPEN_PAREN > < CLOSE_PAREN > (Expression2)? | 
	< NOT > Expression (Expression2)? |
	< OPEN_PAREN > Expression (Expression2)? < CLOSE_PAREN > (Expression2)?
;

Expression2:
	( <AND> | <LESS_THAN> | <PLUS> | <MINUS> | <TIMES> | <DIVIDE>) Expression |
	<OPEN_BRACKETS> Expression <CLOSE_BRACKETS> (Expression2)? |
	<PERIOD> ( <LENGTH> (Expression2)? | (<IDENTIFIER> <OPEN_PAREN> (Expression ( <COMMA> Expression )* )? <CLOSE_PAREN> (Expression2)? ))
;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	<INTEGER_LITERAL>
	(
		(< TIMES > | < DIVIDE >)
		<INTEGER_LITERAL>
	)?
;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}